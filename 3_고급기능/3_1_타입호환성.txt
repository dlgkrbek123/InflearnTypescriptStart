------------------------------------------------------------

타입 호환성
- 어떤 타입을 다른 타입으로 취급해도 되는지 판단하는 것
- 이를 활용해 컴파일 타임에 호환되지 않는 타입을 찾아내는 것

- 할당가능을 판단은 집합론에 의해 결정
- 큰 타입을 작은 타입의 집합에 할당 불가
- 작은 타입의 값을 큰 타입에 할당 가능

------------------------------------------------------------

- ts는 타입명보다는 내부구조에 기반해 타입호환성을 검사
- structural typing

interface Person {
  name: string;
  age: number;
}
interface Product {
  name: string;
  age: number;
}

const person: Person = { name: "mike", age: 23 };
const product: Product = person;

// Person과 Product의 타입명은 다르지만 구조가 동일하므로 할당 가능

------------------------------------------------------------

인터페이스간 할당 가능 조건 ( A => B )

1. B의 모든 필수 속성이 A에도 존재해야함
2. 같은 속성이름에 대해서, A의 속성이 B의 속성에 할당가능해야 한다.

------------------------------------------------------------

인터페이스에 속성이 많을수록 제약이 많아지며 집합은 작아진다.

interface Person {
  name: string;
}
interface Product {
  name: string;
  age: number;
}

const obj = { name: "mike", age: '23', city: 'abc' };
let person: Person = obj;
let product: Product = obj; // 에러 발생

person = product; // 가능
product = person; // 불가능
 
------------------------------------------------------------

함수간 할당가능 조건 (A => B)
1. A의 매개변수의 개수가 B의 매개변수의 개수보다 적어야 한다.
2. 같은 위치의 매개변수에 대해 B의 매개변수가 A의 매개변수로 할당가능해야 한다.
3. A의 리턴값은 B의 리턴값으로 할당가능해야 한다.



------------------------------------------------------------